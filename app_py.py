# # -*- coding: utf-8 -*-
# """app.py

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/19C76ph2wDOV1Z5Yu74aGyKPBnDZHntc9
# """


# # !pip install streamlit

# # !pip install lime

# # !pip install tf-keras-vis

# import streamlit as st
# import tensorflow as tf
# import numpy as np
# import cv2
# import os
# import matplotlib.pyplot as plt
# from lime import lime_image
# from skimage.segmentation import mark_boundaries
# from PIL import Image
# from tf_keras_vis.gradcam_plus_plus import GradcamPlusPlus
# from tf_keras_vis.utils.model_modifiers import ReplaceToLinear
# from tf_keras_vis.utils.scores import CategoricalScore

# # Set up
# st.set_page_config(page_title="DR Classifier", layout="wide")
# st.title("Diabetic Retinopathy Classifier with EfficientnetB0")
# st.write("Upload a retina image to view predictions and explanations.")

# # Class names
# CLASS_NAMES = ['No DR', 'Mild', 'Moderate', 'Severe', 'Proliferative DR']
# MODEL_PATH = 'EfficientNetB0_best.keras'
# IMG_SIZE = 224

# def load_model():
#     return tf.keras.models.load_model(MODEL_PATH)

# def preprocess_image(img):
#     img = img.resize((IMG_SIZE, IMG_SIZE))
#     img = np.array(img) / 255.0
#     return np.expand_dims(img, axis=0), img

# def gradcam_heatmap(model, img_input):
#     gradcam = GradcamPlusPlus(model, model_modifier=ReplaceToLinear(), clone=True)
#     pred_class = np.argmax(model.predict(img_input))

#     # Generate heatmap from GradCAM++
#     heatmap = gradcam(CategoricalScore(pred_class), img_input)[0]

#     # Resize and squeeze to 2D
#     heatmap = tf.image.resize(tf.expand_dims(heatmap, -1), img_input.shape[1:3]).numpy()
#     heatmap = np.squeeze(heatmap)

#     # Normalize and convert to uint8
#     heatmap_norm = (heatmap - np.min(heatmap)) / (np.max(heatmap) - np.min(heatmap) + 1e-8)
#     heatmap_uint8 = np.uint8(255 * heatmap_norm)

#     # Apply OpenCV colormap
#     heatmap_color = cv2.applyColorMap(heatmap_uint8, cv2.COLORMAP_JET)

#     # Prepare original image for overlay
#     original_img = np.uint8(img_input[0] * 255)

#     # Overlay heatmap on original image
#     overlay = cv2.addWeighted(original_img, 0.6, heatmap_color, 0.4, 0)

#     return overlay, pred_class

# def lime_explanation(model, img_raw):
#     explainer = lime_image.LimeImageExplainer()
#     explanation = explainer.explain_instance(
#         np.array(img_raw),
#         classifier_fn=lambda x: model.predict(tf.keras.applications.efficientnet.preprocess_input(x)),
#         top_labels=1,
#         hide_color=0,
#         num_samples=1000
#     )
#     lime_img, mask = explanation.get_image_and_mask(
#         label=explanation.top_labels[0],
#         positive_only=True,
#         hide_rest=False,
#         num_features=10
#     )
#     return mark_boundaries(lime_img, mask)

# # UI elements
# uploaded_file = st.file_uploader("Upload Retina Image", type=["png", "jpg", "jpeg"])

# if uploaded_file:
#     # Display original
#     st.image(uploaded_file, caption="Uploaded Image", use_column_width=True)

#     # Load image and model
#     image = Image.open(uploaded_file).convert("RGB")
#     model = load_model()

#     # Preprocess and predict
#     img_input, img_display = preprocess_image(image)
#     gradcam_img, pred_class = gradcam_heatmap(model, img_input)
#     lime_img = lime_explanation(model, image.resize((IMG_SIZE, IMG_SIZE)))

#     col1, col2 = st.columns(2)

#     with col1:
#         st.subheader("Grad-CAM++")
#         st.image(gradcam_img, caption=f"Predicted: {CLASS_NAMES[pred_class]}", use_column_width=True)

#     with col2:
#         st.subheader("LIME Explanation")
#         st.image(lime_img, caption="LIME Interpretation", use_column_width=True)

#     st.success(f"Predicted Class: {CLASS_NAMES[pred_class]}")

import streamlit as st
import tensorflow as tf
import numpy as np
import cv2
from lime import lime_image
from skimage.segmentation import mark_boundaries
from PIL import Image
from tf_keras_vis.gradcam_plus_plus import GradcamPlusPlus
from tf_keras_vis.utils.model_modifiers import ReplaceToLinear
from tf_keras_vis.utils.scores import CategoricalScore

# Set up
st.set_page_config(page_title="DR Classifier", layout="wide")
st.title("Diabetic Retinopathy Classifier with EfficientNetB0")
st.write("Upload a retina image to view predictions with Grad-CAM++ and LIME explanations.")

# Constants
CLASS_NAMES = ['No DR', 'Mild', 'Moderate', 'Severe', 'Proliferative DR']
MODEL_PATH = 'EfficientNetB0_best.keras'
IMG_SIZE = 224

# Load model
@st.cache_resource
def load_model():
    return tf.keras.models.load_model(MODEL_PATH)

# Preprocessing function
def preprocess_image(img):
    img = img.resize((IMG_SIZE, IMG_SIZE))
    img_array = tf.keras.applications.efficientnet.preprocess_input(np.array(img))
    return np.expand_dims(img_array, axis=0), img

# Grad-CAM++
# def gradcam_heatmap(model, img_input):
#     gradcam = GradcamPlusPlus(model, model_modifier=ReplaceToLinear(), clone=True)
#     pred_class = np.argmax(model.predict(img_input))
#     heatmap = gradcam(CategoricalScore(pred_class), img_input)[0]
#     heatmap = tf.image.resize(tf.expand_dims(heatmap, -1), img_input.shape[1:3]).numpy()
#     heatmap = np.squeeze(heatmap)
#     heatmap_norm = (heatmap - np.min(heatmap)) / (np.max(heatmap) - np.min(heatmap) + 1e-8)
#     heatmap_uint8 = np.uint8(255 * heatmap_norm)
#     heatmap_color = cv2.applyColorMap(heatmap_uint8, cv2.COLORMAP_JET)
#     original_img = np.uint8(img_input[0] * 255)
#     overlay = cv2.addWeighted(original_img, 0.6, heatmap_color, 0.4, 0)
#     return overlay, pred_class
def gradcam_heatmap(model, img_input):
    gradcam = GradcamPlusPlus(model, model_modifier=ReplaceToLinear(), clone=True)
    pred_class = np.argmax(model.predict(img_input))

    # Use the last convolutional layer of EfficientNetB0 explicitly
    heatmap = gradcam(
        CategoricalScore(pred_class),
        img_input,
        penultimate_layer='top_conv'  # This is the key fix!
    )[0]

    heatmap = tf.image.resize(tf.expand_dims(heatmap, -1), img_input.shape[1:3]).numpy()
    heatmap = np.squeeze(heatmap)
    heatmap_norm = (heatmap - np.min(heatmap)) / (np.max(heatmap) - np.min(heatmap) + 1e-8)
    heatmap_uint8 = np.uint8(255 * heatmap_norm)
    heatmap_color = cv2.applyColorMap(heatmap_uint8, cv2.COLORMAP_JET)
    original_img = np.uint8(img_input[0] * 255)
    overlay = cv2.addWeighted(original_img, 0.6, heatmap_color, 0.4, 0)

    return overlay, pred_class

# LIME Explanation
def lime_explanation(model, img_raw):
    explainer = lime_image.LimeImageExplainer()
    explanation = explainer.explain_instance(
        np.array(img_raw),
        classifier_fn=lambda x: model.predict(tf.keras.applications.efficientnet.preprocess_input(x)),
        top_labels=1,
        hide_color=0,
        num_samples=1000
    )
    lime_img, mask = explanation.get_image_and_mask(
        label=explanation.top_labels[0],
        positive_only=True,
        hide_rest=False,
        num_features=10
    )
    return mark_boundaries(lime_img, mask)

# UI
uploaded_file = st.file_uploader("Upload Retina Image", type=["png", "jpg", "jpeg"])

if uploaded_file:
    st.image(uploaded_file, caption="Uploaded Image", use_column_width=True)
    image = Image.open(uploaded_file).convert("RGB")
    model = load_model()
    for i, layer in enumerate(model.layers):
        print(f"{i}: {layer.name} - {layer.__class__.__name__}")
    # Process + Predict
    img_input, img_display = preprocess_image(image)
    gradcam_img, pred_class = gradcam_heatmap(model, img_input)
    lime_img = lime_explanation(model, image.resize((IMG_SIZE, IMG_SIZE)))

    col1, col2 = st.columns(2)
    with col1:
        st.subheader("Grad-CAM++")
        st.image(gradcam_img, caption=f"Predicted: {CLASS_NAMES[pred_class]}", use_column_width=True)

    with col2:
        st.subheader("LIME Explanation")
        st.image(lime_img, caption="LIME Interpretation", use_column_width=True)

    st.success(f"Predicted Class: {CLASS_NAMES[pred_class]}")

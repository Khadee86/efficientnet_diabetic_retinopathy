# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19C76ph2wDOV1Z5Yu74aGyKPBnDZHntc9
"""

import streamlit as st
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model
from tensorflow.keras.applications.efficientnet import preprocess_input
from tensorflow.keras.preprocessing import image as keras_image
from PIL import Image
import matplotlib.pyplot as plt
import io
import lime
from lime import lime_image
from skimage.segmentation import mark_boundaries

# ---------- CONFIG ----------
MODEL_PATH = "EfficientNetb0_best.keras"
IMAGE_SIZE = (224, 224)
CLASS_NAMES = ['No DR', 'Mild', 'Moderate', 'Severe', 'Proliferative DR']

# ---------- LOAD MODEL ----------
@st.cache_resource
def load_efficientnetb0():
    model = load_model(MODEL_PATH)
    return model

model = load_efficientnetb0()

# ---------- HELPER FUNCTIONS ----------

def preprocess_img_for_model(pil_img):
    img_resized = pil_img.resize(IMAGE_SIZE)
    img_array = np.array(img_resized)
    img_preprocessed = preprocess_input(img_array)
    img_expanded = np.expand_dims(img_preprocessed, axis=0)
    return img_expanded, img_array

def generate_gradcam(model, img_array, last_conv_layer="top_conv"):
    grad_model = tf.keras.models.Model(
        [model.inputs],
        [model.get_layer(last_conv_layer).output, model.output]
    )

    with tf.GradientTape() as tape:
        inputs = tf.cast(np.expand_dims(preprocess_input(img_array), axis=0), tf.float32)
        conv_outputs, predictions = grad_model(inputs)
        class_idx = tf.argmax(predictions[0])
        loss = predictions[:, class_idx]

    grads = tape.gradient(loss, conv_outputs)[0]
    conv_outputs = conv_outputs[0]

    weights = tf.reduce_mean(grads, axis=(0, 1))
    cam = np.dot(conv_outputs, weights.numpy())

    cam = np.maximum(cam, 0)
    cam = cam / np.max(cam)
    cam = tf.image.resize(cam[..., np.newaxis], IMAGE_SIZE).numpy().squeeze()

    heatmap = np.uint8(255 * cam)
    heatmap = np.stack([heatmap] * 3, axis=-1)

    overlay = np.uint8(0.4 * heatmap + 0.6 * img_array)
    return overlay

def generate_lime_explanation(model, img_array):
    def predict_fn(images):
        images = preprocess_input(images)
        return model.predict(images)

    explainer = lime_image.LimeImageExplainer()
    explanation = explainer.explain_instance(
        img_array,
        predict_fn,
        top_labels=1,
        hide_color=0,
        num_samples=1000
    )
    lime_img, mask = explanation.get_image_and_mask(
        explanation.top_labels[0],
        positive_only=True,
        num_features=5,
        hide_rest=False
    )
    return mark_boundaries(lime_img, mask)

# ---------- STREAMLIT UI ----------
st.title("Diabetic Retinopathy Classifier")
st.write("Upload a retinal fundus image to classify DR severity using EfficientNetB0.")

uploaded_file = st.file_uploader("Upload Image", type=["jpg", "jpeg", "png"])

if uploaded_file is not None:
    image = Image.open(uploaded_file).convert('RGB')
    st.image(image, caption="Uploaded Image", use_column_width=True)

    img_expanded, original_array = preprocess_img_for_model(image)

    preds = model.predict(img_expanded)[0]
    predicted_class = np.argmax(preds)
    confidence = preds[predicted_class]

    st.subheader("Prediction")
    st.write(f"**Class:** {CLASS_NAMES[predicted_class]}")
    st.write(f"**Confidence:** {confidence:.2f}")

    # ---------- GRAD-CAM++ ----------
    if st.checkbox("Show Grad-CAM++"):
        st.subheader("Grad-CAM++ Explanation")
        gradcam_overlay = generate_gradcam(model, original_array)
        st.image(gradcam_overlay, caption="Grad-CAM++", use_column_width=True)

    # ---------- LIME ----------
    if st.checkbox("Show LIME Explanation"):
        st.subheader("LIME Explanation")
        lime_img = generate_lime_explanation(model, original_array)
        st.image(lime_img, caption="LIME Explanation", use_column_width=True)
